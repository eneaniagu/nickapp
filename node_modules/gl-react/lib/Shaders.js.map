{"version":3,"sources":["../src/Shaders.js"],"names":["ShaderID","shaderDefinitions","shaderNames","shaderResults","genShaderId","i","toString","staticVerts","isShaderIdentifier","shaderIdentifier","type","id","ensureShaderDefinition","definition","ctx","frag","versionDef","inferGLSLVersion","glsl","indexOf","line1","slice","startsWith","length","addGLSLName","name","shaderDefinitionToShaderInfo","vert","trim","version","vertVersion","Error","shaderInfoEquals","s1","s2","Shaders","global","__glReactShaders","create","shadersDef","sheet","Object","keys","forEach","k","shaderId","freeze","result","getName","String","getShortName","get"],"mappings":";;;;;;;;;;;AACA;;AACA;;;;AAGA,MAAMA,QAAQ,GAAG,UAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAiDA,MAAMC,iBAAwD,GAAG,EAAjE;AACA,MAAMC,WAAwC,GAAG,EAAjD;AACA,MAAMC,aAA8C,GAAG,EAAvD;;AAEA,MAAMC,WAAW,GAAG,CAAEC,CAAD,IAAO,MAAM,CAAC,EAAEA,CAAH,EAAMC,QAAN,EAAd,EAAgC,CAAhC,CAApB;;AAEA,MAAMC,WAAW,GAAG;AAClB,SAAO,kBAAK;AACd;AACA;AACA;AACA;AACA;AACA,EAPoB;AAQlB,YAAU,kBAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AAdoB,CAApB;;AAiBO,SAASC,kBAAT,CAA4BC,gBAA5B,EAA8D;AACnE,SACE,OAAOA,gBAAP,KAA4B,QAA5B,IACA,CAAC,CAACA,gBADF,IAEAA,gBAAgB,CAACC,IAAjB,KAA0BV,QAF1B,IAGA,OAAOS,gBAAgB,CAACE,EAAxB,KAA+B,QAJjC;AAMD;;AAEM,SAASC,sBAAT,CACLC,UADK,EAELC,GAAY,GAAG,EAFV,EAGa;AAClB,0BACED,UAAU,IAAI,OAAOA,UAAU,CAACE,IAAlB,KAA2B,QAD3C,EAEE,4CAA4CD,GAF9C;AAIA,SAAOD,UAAP;AACD;;AAED,MAAMG,UAAU,GAAG,UAAnB;;AACA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,QAAMb,CAAC,GAAGa,IAAI,CAACC,OAAL,CAAa,IAAb,CAAV;AACA,QAAMC,KAAK,GAAGf,CAAC,GAAG,CAAC,CAAL,GAASa,IAAI,CAACG,KAAL,CAAW,CAAX,EAAchB,CAAd,CAAT,GAA4Ba,IAA1C;;AACA,MAAIE,KAAK,CAACE,UAAN,CAAiBN,UAAjB,CAAJ,EAAkC;AAChC,WAAOI,KAAK,CAACC,KAAN,CAAYL,UAAU,CAACO,MAAX,GAAoB,CAAhC,CAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED,MAAMC,WAAW,GAAG,CAACN,IAAD,EAAeO,IAAf,KAClB,CAACA,IAAD,GAAQP,IAAR,GAAeA,IAAI,GAAG,wBAAP,GAAkCO,IAAlC,GAAyC,IAD1D;;AAGO,SAASC,4BAAT,CACL;AAAEX,EAAAA,IAAF;AAAQY,EAAAA;AAAR,CADK,EAELF,IAFK,EAGO;AACZV,EAAAA,IAAI,GAAGA,IAAI,CAACa,IAAL,EAAP;AACA,QAAMC,OAAO,GAAGZ,gBAAgB,CAACF,IAAD,CAAhC;;AACA,MAAIY,IAAJ,EAAU;AACRA,IAAAA,IAAI,GAAGA,IAAI,CAACC,IAAL,EAAP;AACA,UAAME,WAAW,GAAGb,gBAAgB,CAACU,IAAD,CAApC;;AACA,QAAIE,OAAO,KAAKC,WAAhB,EAA6B;AAC3B,YAAM,IAAIC,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF,GAND,MAMO;AACLJ,IAAAA,IAAI,GAAGpB,WAAW,CAACsB,OAAD,CAAlB;;AACA,QAAI,CAACF,IAAL,EAAW;AACT,YAAM,IAAII,KAAJ,CACJ,qEACEF,OADF,GAEE,GAHE,CAAN;AAKD;AACF;;AACDd,EAAAA,IAAI,GAAGS,WAAW,CAACT,IAAD,EAAOU,IAAP,CAAlB;AACAE,EAAAA,IAAI,GAAGH,WAAW,CAACG,IAAD,EAAOF,IAAP,CAAlB;AACA,SAAO;AACLV,IAAAA,IADK;AAELY,IAAAA;AAFK,GAAP;AAID;;AAEM,SAASK,gBAAT,CAA0BC,EAA1B,EAA0CC,EAA1C,EAAmE;AACxE,SAAOD,EAAE,CAAClB,IAAH,KAAYmB,EAAE,CAACnB,IAAf,IAAuBkB,EAAE,CAACN,IAAH,KAAYO,EAAE,CAACP,IAA7C;AACD;AAED;AACA;AACA;AACA;;;AACA,MAAMQ,OAAO,GAAIC,MAAM,CAACC,gBAAP,GAA0BD,MAAM,CAACC,gBAAP,IAA2B;AACpE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,MAAM,CAAuBC,UAAvB,EAAuD;AAC3D,UAAMC,KAAK,GAAG,EAAd;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAYH,UAAZ,EAAwBI,OAAxB,CAAiCC,CAAD,IAAO;AACrC,YAAM/B,UAAU,GAAGD,sBAAsB,CACvC2B,UAAU,CAACK,CAAD,CAD6B,EAEvC,0BAA0BA,CAA1B,GAA8B,UAFS,CAAzC;AAIA,YAAMjC,EAAE,GAAGP,WAAW,EAAtB;AACA,YAAMyC,QAAQ,GAAGJ,MAAM,CAACK,MAAP,CAAc;AAAEpC,QAAAA,IAAI,EAAEV,QAAR;AAAkBW,QAAAA;AAAlB,OAAd,CAAjB;AACAV,MAAAA,iBAAiB,CAACU,EAAD,CAAjB,GAAwBE,UAAxB;AACAX,MAAAA,WAAW,CAACS,EAAD,CAAX,GAAkBiC,CAAlB;AACAJ,MAAAA,KAAK,CAACI,CAAD,CAAL,GAAWC,QAAX;AACA,YAAME,MAAM,GAAGrB,4BAA4B,CAACb,UAAD,EAAa+B,CAAb,CAA3C;AACAzC,MAAAA,aAAa,CAACQ,EAAD,CAAb,GAAoBoC,MAApB;AACD,KAZD;AAaA,WAAOP,KAAP;AACD,GA9BmE;;AA+BpEQ,EAAAA,OAAO,CAACvC,gBAAD,EAA6C;AAClD,WACE,CAACP,WAAW,CAACO,gBAAgB,CAACE,EAAlB,CAAX,IAAoC,KAArC,IACC,IAAGsC,MAAM,CAACxC,gBAAgB,CAACE,EAAlB,CAAsB,EAFlC;AAID,GApCmE;;AAqCpEuC,EAAAA,YAAY,CAACzC,gBAAD,EAA6C;AACvD,WAAOP,WAAW,CAACO,gBAAgB,CAACE,EAAlB,CAAX,IAAoC,KAA3C;AACD,GAvCmE;;AAwCpEwC,EAAAA,GAAG,CAAC1C,gBAAD,EAAiD;AAClD,4BACEA,gBAAgB,CAACE,EAAjB,IAAuBV,iBADzB,EAEE,0FAFF,EAGEQ,gBAAgB,CAACE,EAHnB;AAKA,WAAOR,aAAa,CAACM,gBAAgB,CAACE,EAAlB,CAApB;AACD;;AA/CmE,CAAtE;eAiDewB,O","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport GLSL from \"./GLSL\";\nimport type { GLSLCode } from \"./GLSL\";\n\nconst ShaderID = \"ShaderID\";\n\n/**\n * An object that contains a `frag` GLSLCode.\n * @example\n *  {\n *    frag: GLSL`...`\n *  }\n */\ntype ShaderDefinition = {|\n  frag: GLSLCode,\n  vert?: GLSLCode,\n|};\n\nexport type { ShaderDefinition };\n\n/**\n *\n */\ntype ShaderIdentifier = {\n  type: typeof ShaderID,\n  id: string,\n};\n\nexport type { ShaderIdentifier };\n\ntype ShaderIdentifierMap<T> = {\n  [key: string]: T,\n};\n\n/**\n * An object map from a key string to a **ShaderDefinition**.\n * @example\n *  {\n *    helloGL: {\n *      frag: GLSL`...`\n *    }\n *  }\n */\ntype ShadersDefinition = {\n  [key: string]: ShaderDefinition,\n};\n\n/**\n * An object map from a key string to a **ShaderIdentifier** that you can pass to `<Node shader>`\n */\ntype ShadersSheet<S: ShadersDefinition> = {\n  [key: $Keys<S>]: ShaderIdentifier,\n};\n\ntype ShaderInfo = {\n  frag: GLSLCode,\n  vert: GLSLCode,\n};\n\nexport type { ShaderInfo };\n\nconst shaderDefinitions: ShaderIdentifierMap<ShaderDefinition> = {};\nconst shaderNames: ShaderIdentifierMap<string> = {};\nconst shaderResults: ShaderIdentifierMap<ShaderInfo> = {};\n\nconst genShaderId = ((i) => () => (++i).toString())(0);\n\nconst staticVerts = {\n  \"100\": GLSL`\nattribute vec2 _p;\nvarying vec2 uv;\nvoid main() {\ngl_Position = vec4(_p,0.0,1.0);\nuv = vec2(0.5, 0.5) * (_p+vec2(1.0, 1.0));\n}`,\n  \"300 es\": GLSL`#version 300 es\nin vec2 _p;\nout vec2 uv;\nvoid main() {\ngl_Position = vec4(_p,0.0,1.0);\nuv = vec2(0.5, 0.5) * (_p+vec2(1.0, 1.0));\n}`,\n};\n\nexport function isShaderIdentifier(shaderIdentifier: mixed): boolean {\n  return (\n    typeof shaderIdentifier === \"object\" &&\n    !!shaderIdentifier &&\n    shaderIdentifier.type === ShaderID &&\n    typeof shaderIdentifier.id === \"string\"\n  );\n}\n\nexport function ensureShaderDefinition(\n  definition: any,\n  ctx?: string = \"\"\n): ShaderDefinition {\n  invariant(\n    definition && typeof definition.frag === \"string\",\n    \"A `frag` GLSL code (string) is required\" + ctx\n  );\n  return definition;\n}\n\nconst versionDef = \"#version\";\nfunction inferGLSLVersion(glsl) {\n  const i = glsl.indexOf(\"\\n\");\n  const line1 = i > -1 ? glsl.slice(0, i) : glsl;\n  if (line1.startsWith(versionDef)) {\n    return line1.slice(versionDef.length + 1);\n  }\n  return \"100\";\n}\n\nconst addGLSLName = (glsl: string, name: ?string) =>\n  !name ? glsl : glsl + \"\\n#define SHADER_NAME \" + name + \"\\n\";\n\nexport function shaderDefinitionToShaderInfo(\n  { frag, vert }: ShaderDefinition,\n  name: string\n): ShaderInfo {\n  frag = frag.trim();\n  const version = inferGLSLVersion(frag);\n  if (vert) {\n    vert = vert.trim();\n    const vertVersion = inferGLSLVersion(vert);\n    if (version !== vertVersion) {\n      throw new Error(\"GLSL shader vert and frag version must match\");\n    }\n  } else {\n    vert = staticVerts[version];\n    if (!vert) {\n      throw new Error(\n        \"gl-react: could not find static vertex shader for GLSL version '\" +\n          version +\n          \"'\"\n      );\n    }\n  }\n  frag = addGLSLName(frag, name);\n  vert = addGLSLName(vert, name);\n  return {\n    frag,\n    vert,\n  };\n}\n\nexport function shaderInfoEquals(s1: ShaderInfo, s2: ShaderInfo): boolean {\n  return s1.frag === s2.frag && s1.vert === s2.vert;\n}\n\n/**\n * Define shaders statically.\n * @namespace\n */\nconst Shaders = (global.__glReactShaders = global.__glReactShaders || {\n  /**\n   * @memberof Shaders\n   * @param {ShadersDefinition} shadersDef - an object that statically define all shaders.\n   * @returns {ShadersSheet}, an object map that returns a ShaderIdentifier for each shader key defined in the shaders definition.\n   * @example\n   *  const shaders = Shaders.create({\n   *    helloGL: {\n   *      frag: GLSL`...`\n   *    }\n   *  });\n   *  ...\n   *  <Node shader={shaders.helloGL} />\n   */\n  create<S: ShadersDefinition>(shadersDef: S): ShadersSheet<S> {\n    const sheet = {};\n    Object.keys(shadersDef).forEach((k) => {\n      const definition = ensureShaderDefinition(\n        shadersDef[k],\n        \" in Shaders.create({ \" + k + \": ... })\"\n      );\n      const id = genShaderId();\n      const shaderId = Object.freeze({ type: ShaderID, id });\n      shaderDefinitions[id] = definition;\n      shaderNames[id] = k;\n      sheet[k] = shaderId;\n      const result = shaderDefinitionToShaderInfo(definition, k);\n      shaderResults[id] = result;\n    });\n    return sheet;\n  },\n  getName(shaderIdentifier: ShaderIdentifier): string {\n    return (\n      (shaderNames[shaderIdentifier.id] || \"???\") +\n      `#${String(shaderIdentifier.id)}`\n    );\n  },\n  getShortName(shaderIdentifier: ShaderIdentifier): string {\n    return shaderNames[shaderIdentifier.id] || \"???\";\n  },\n  get(shaderIdentifier: ShaderIdentifier): ShaderInfo {\n    invariant(\n      shaderIdentifier.id in shaderDefinitions,\n      \"Shader %s does not exist. Make sure you don't have gl-react dup issue: `npm ls gl-react`\",\n      shaderIdentifier.id\n    );\n    return shaderResults[shaderIdentifier.id];\n  },\n});\nexport default Shaders;\n"],"file":"Shaders.js"}