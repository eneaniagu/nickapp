{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n|--------------------------------------------------------------------------\n| Authenticator.\n|--------------------------------------------------------------------------\n|\n| A set of functions related to user authentication. \n|\n*/\nimport axios from \"axios\";\nimport { protectedRoutes } from \"./../../config/config\";\nexport class AuthGuard {\n  /**\n   * An array of routes that should not be accessible by unauthenticated users.\n   */\n\n  /**\n   * The constructor function.\n   */\n  constructor() {\n    _defineProperty(this, \"protectedRoutes\", void 0);\n\n    this.protectedRoutes = protectedRoutes;\n  }\n  /**\n   * Get the current user from the database and redirect to dashboard if successful.\n   *\n   * @param {IncomingMessage} req\n   *   The request object.\n   * @param {ServerResponse} res\n   *   The response object.\n   * @param {string} destination\n   *   The destination URL the user will be redirected to if he's authenticated.\n   *\n   * @return {object}\n   *  An empty object. It is still necessary to return obj as getServerSideProps() requires it.\n   */\n\n\n  async redirectOnAuthentication(req, res, destination) {\n    try {\n      // CSRF.\n      await axios.get(\"/sanctum/csrf-cookie\");\n      /**\n       * As the API call is executed on the server it by\n       * default does not have the cookies set in the browser.\n       * Fortunately, we can extract these cookies from the req object\n       * and attach them to the api call.\n       */\n\n      const user = await axios.get(\"/api/user\", {\n        headers: {\n          Cookie: req.headers.cookie\n        }\n      }); // Redirect to dashboard if user is logged in.\n\n      if (user.status === 200) {\n        res.writeHead(301, {\n          Location: destination\n        });\n        res.end();\n        return {\n          props: {}\n        };\n      } else {\n        return {\n          props: {}\n        };\n      }\n    } catch (error) {\n      return {\n        props: {}\n      };\n    }\n  }\n  /**\n   * Load the currently logged in user from DB.\n   *\n   * @param {object} req\n   *   The request object.\n   */\n\n\n  async authenticateUser(req, res, pathname) {\n    const isNoProtectedRoute = this.isNoProtectedRoute(pathname);\n\n    try {\n      // CSRF.\n      await axios.get(\"/sanctum/csrf-cookie\"); // If there are no cookies and the route is protected, redirect to login.\n\n      if (!req.headers.cookie && !isNoProtectedRoute) {\n        /**\n         * No further redirect if we're already on the login\n         * path, as we otherwisely would be caught in an\n         * infinite loop of redirections to /user/login.\n         */\n        if (pathname === \"/user/login\") {\n          res.end();\n          return {\n            user: false\n          };\n        }\n\n        res.writeHead(302, {\n          Location: \"/user/login\"\n        });\n        res.end();\n        return {\n          user: false\n        };\n      }\n      /**\n       * As the API call is executed on the server it by\n       * default does not have the cookies set in the browser.\n       * Fortunately, we can extract these cookies from the req object\n       * and attach them to the api call.\n       */\n\n\n      const response = await axios.get(\"/api/user\", {\n        headers: {\n          Cookie: req.headers.cookie\n        }\n      }); // Abort if request was not successful.\n\n      if (response.status !== 200) {\n        res.end();\n        return {\n          user: false\n        };\n      } // New var with the current user data.\n\n\n      const currentUser = response.data; // If user is authenticated and he requests login or register, redirect to dashboard.\n\n      if (currentUser && (pathname === \"/user/register\" || pathname === \"/user/login\")) {\n        res.writeHead(302, {\n          Location: \"/dashboard\"\n        });\n        res.end();\n      } // Redirect to login if user is not authenticated and tries to access protected route.\n      else if (!currentUser && !isNoProtectedRoute) {\n          res.writeHead(302, {\n            Location: \"/user/login\"\n          });\n          res.end();\n          return {\n            user: false\n          };\n        } // Return the currently authenticated user.\n\n\n      return {\n        user: currentUser\n      };\n    } catch (error) {\n      /**\n       * If the authentication fails (e.g. invalid session)\n       * the API will send a 401 response. If we're on a\n       * protected route, redirect to the login page.\n       */\n      if (error.response && error.response.status === 401 && !isNoProtectedRoute) {\n        if (pathname === \"/user/login\") {\n          return {\n            user: false\n          };\n        }\n\n        res.writeHead(302, {\n          Location: \"/user/login\"\n        });\n        res.end();\n      }\n\n      return {\n        user: false\n      };\n    }\n  }\n  /**\n   * Check if a given path is a protected one.\n   *\n   * @param {string} pathname\n   *   The current pathname.\n   *\n   * @return {boolean}\n   *   True if it is a protected route.\n   */\n\n\n  isNoProtectedRoute(pathname) {\n    return this.protectedRoutes.every(route => {\n      return !pathname.startsWith(route);\n    });\n  }\n\n}","map":{"version":3,"sources":["/var/www/html/SourceApi/shoppingApi/client/services/Auth/AuthGuard.tsx"],"names":["axios","protectedRoutes","AuthGuard","constructor","redirectOnAuthentication","req","res","destination","get","user","headers","Cookie","cookie","status","writeHead","Location","end","props","error","authenticateUser","pathname","isNoProtectedRoute","response","currentUser","data","every","route","startsWith"],"mappings":"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","sourcesContent":["/*\n|--------------------------------------------------------------------------\n| Authenticator.\n|--------------------------------------------------------------------------\n|\n| A set of functions related to user authentication. \n|\n*/\nimport axios from \"axios\";\nimport { IncomingMessage, ServerResponse } from \"http\";\nimport { protectedRoutes } from \"./../../config/config\";\n\nexport class AuthGuard {\n    /**\n     * An array of routes that should not be accessible by unauthenticated users.\n     */\n    private protectedRoutes: string[];\n\n    /**\n     * The constructor function.\n     */\n    constructor() {\n        this.protectedRoutes = protectedRoutes;\n    }\n\n    /**\n     * Get the current user from the database and redirect to dashboard if successful.\n     *\n     * @param {IncomingMessage} req\n     *   The request object.\n     * @param {ServerResponse} res\n     *   The response object.\n     * @param {string} destination\n     *   The destination URL the user will be redirected to if he's authenticated.\n     *\n     * @return {object}\n     *  An empty object. It is still necessary to return obj as getServerSideProps() requires it.\n     */\n    public async redirectOnAuthentication(\n        req: IncomingMessage,\n        res: ServerResponse,\n        destination: string\n    ) {\n        try {\n            // CSRF.\n            await axios.get(\"/sanctum/csrf-cookie\");\n\n            /**\n             * As the API call is executed on the server it by\n             * default does not have the cookies set in the browser.\n             * Fortunately, we can extract these cookies from the req object\n             * and attach them to the api call.\n             */\n            const user = await axios.get(\"/api/user\", {\n                headers: { Cookie: req.headers.cookie },\n            });\n\n            // Redirect to dashboard if user is logged in.\n            if (user.status === 200) {\n                res.writeHead(301, {\n                    Location: destination,\n                });\n                res.end();\n                return { props: {} };\n            } else {\n                return {\n                    props: {},\n                };\n            }\n        } catch (error) {\n            return { props: {} };\n        }\n    }\n\n    /**\n     * Load the currently logged in user from DB.\n     *\n     * @param {object} req\n     *   The request object.\n     */\n    public async authenticateUser(\n        req: IncomingMessage,\n        res: ServerResponse,\n        pathname: string\n    ) {\n        const isNoProtectedRoute = this.isNoProtectedRoute(pathname);\n        try {\n            // CSRF.\n            await axios.get(\"/sanctum/csrf-cookie\");\n\n            // If there are no cookies and the route is protected, redirect to login.\n            if (!req.headers.cookie && !isNoProtectedRoute) {\n                /**\n                 * No further redirect if we're already on the login\n                 * path, as we otherwisely would be caught in an\n                 * infinite loop of redirections to /user/login.\n                 */\n                if (pathname === \"/user/login\") {\n                    res.end();\n                    return { user: false };\n                }\n\n                res.writeHead(302, {\n                    Location: \"/user/login\",\n                });\n                res.end();\n                return { user: false };\n            }\n\n            /**\n             * As the API call is executed on the server it by\n             * default does not have the cookies set in the browser.\n             * Fortunately, we can extract these cookies from the req object\n             * and attach them to the api call.\n             */\n            const response = await axios.get(\"/api/user\", {\n                headers: { Cookie: req.headers.cookie },\n            });\n\n            // Abort if request was not successful.\n            if (response.status !== 200) {\n                res.end();\n                return { user: false };\n            }\n\n            // New var with the current user data.\n            const currentUser = response.data;\n\n            // If user is authenticated and he requests login or register, redirect to dashboard.\n            if (\n                currentUser &&\n                (pathname === \"/user/register\" || pathname === \"/user/login\")\n            ) {\n                res.writeHead(302, {\n                    Location: \"/dashboard\",\n                });\n                res.end();\n            }\n            // Redirect to login if user is not authenticated and tries to access protected route.\n            else if (!currentUser && !isNoProtectedRoute) {\n                res.writeHead(302, {\n                    Location: \"/user/login\",\n                });\n                res.end();\n                return { user: false };\n            }\n\n            // Return the currently authenticated user.\n            return {\n                user: currentUser,\n            };\n        } catch (error) {\n            /**\n             * If the authentication fails (e.g. invalid session)\n             * the API will send a 401 response. If we're on a\n             * protected route, redirect to the login page.\n             */\n\n            if (\n                error.response &&\n                error.response.status === 401 &&\n                !isNoProtectedRoute\n            ) {\n                if (pathname === \"/user/login\") {\n                    return { user: false };\n                }\n                res.writeHead(302, {\n                    Location: \"/user/login\",\n                });\n                res.end();\n            }\n            return { user: false };\n        }\n    }\n\n    /**\n     * Check if a given path is a protected one.\n     *\n     * @param {string} pathname\n     *   The current pathname.\n     *\n     * @return {boolean}\n     *   True if it is a protected route.\n     */\n    public isNoProtectedRoute(pathname: string): boolean {\n        return this.protectedRoutes.every((route) => {\n            return !pathname.startsWith(route);\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}