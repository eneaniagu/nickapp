{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\n/*\n|--------------------------------------------------------------------------\n| Authenticator.\n|--------------------------------------------------------------------------\n|\n| A set of functions related to user authentication. \n|\n*/\nimport axios from \"axios\";\nimport { protectedRoutes } from \"./../../config/config\";\nexport var AuthGuard = /*#__PURE__*/function () {\n  /**\n   * An array of routes that should not be accessible by unauthenticated users.\n   */\n\n  /**\n   * The constructor function.\n   */\n  function AuthGuard() {\n    _classCallCheck(this, AuthGuard);\n\n    _defineProperty(this, \"protectedRoutes\", void 0);\n\n    this.protectedRoutes = protectedRoutes;\n  }\n  /**\n   * Get the current user from the database and redirect to dashboard if successful.\n   *\n   * @param {IncomingMessage} req\n   *   The request object.\n   * @param {ServerResponse} res\n   *   The response object.\n   * @param {string} destination\n   *   The destination URL the user will be redirected to if he's authenticated.\n   *\n   * @return {object}\n   *  An empty object. It is still necessary to return obj as getServerSideProps() requires it.\n   */\n\n\n  _createClass(AuthGuard, [{\n    key: \"redirectOnAuthentication\",\n    value: function () {\n      var _redirectOnAuthentication = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res, destination) {\n        var user;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return axios.get(\"/sanctum/csrf-cookie\");\n\n              case 3:\n                _context.next = 5;\n                return axios.get(\"/api/user\", {\n                  headers: {\n                    Cookie: req.headers.cookie\n                  }\n                });\n\n              case 5:\n                user = _context.sent;\n\n                if (!(user.status === 200)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                res.writeHead(301, {\n                  Location: destination\n                });\n                res.end();\n                return _context.abrupt(\"return\", {\n                  props: {}\n                });\n\n              case 12:\n                return _context.abrupt(\"return\", {\n                  props: {}\n                });\n\n              case 13:\n                _context.next = 18;\n                break;\n\n              case 15:\n                _context.prev = 15;\n                _context.t0 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  props: {}\n                });\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 15]]);\n      }));\n\n      function redirectOnAuthentication(_x, _x2, _x3) {\n        return _redirectOnAuthentication.apply(this, arguments);\n      }\n\n      return redirectOnAuthentication;\n    }()\n    /**\n     * Load the currently logged in user from DB.\n     *\n     * @param {object} req\n     *   The request object.\n     */\n\n  }, {\n    key: \"authenticateUser\",\n    value: function () {\n      var _authenticateUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, pathname) {\n        var isNoProtectedRoute, response, currentUser;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                isNoProtectedRoute = this.isNoProtectedRoute(pathname);\n                _context2.prev = 1;\n                _context2.next = 4;\n                return axios.get(\"/sanctum/csrf-cookie\");\n\n              case 4:\n                if (!(!req.headers.cookie && !isNoProtectedRoute)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                if (!(pathname === \"/user/login\")) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                res.end();\n                return _context2.abrupt(\"return\", {\n                  user: false\n                });\n\n              case 8:\n                res.writeHead(302, {\n                  Location: \"/user/login\"\n                });\n                res.end();\n                return _context2.abrupt(\"return\", {\n                  user: false\n                });\n\n              case 11:\n                _context2.next = 13;\n                return axios.get(\"/api/user\", {\n                  headers: {\n                    Cookie: req.headers.cookie\n                  }\n                });\n\n              case 13:\n                response = _context2.sent;\n\n                if (!(response.status !== 200)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                res.end();\n                return _context2.abrupt(\"return\", {\n                  user: false\n                });\n\n              case 17:\n                // New var with the current user data.\n                currentUser = response.data; // If user is authenticated and he requests login or register, redirect to dashboard.\n\n                if (!(currentUser && (pathname === \"/user/register\" || pathname === \"/user/login\"))) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                res.writeHead(302, {\n                  Location: \"/dashboard\"\n                });\n                res.end();\n                _context2.next = 27;\n                break;\n\n              case 23:\n                if (!(!currentUser && !isNoProtectedRoute)) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                res.writeHead(302, {\n                  Location: \"/user/login\"\n                });\n                res.end();\n                return _context2.abrupt(\"return\", {\n                  user: false\n                });\n\n              case 27:\n                return _context2.abrupt(\"return\", {\n                  user: currentUser\n                });\n\n              case 30:\n                _context2.prev = 30;\n                _context2.t0 = _context2[\"catch\"](1);\n\n                if (!(_context2.t0.response && _context2.t0.response.status === 401 && !isNoProtectedRoute)) {\n                  _context2.next = 37;\n                  break;\n                }\n\n                if (!(pathname === \"/user/login\")) {\n                  _context2.next = 35;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  user: false\n                });\n\n              case 35:\n                res.writeHead(302, {\n                  Location: \"/user/login\"\n                });\n                res.end();\n\n              case 37:\n                return _context2.abrupt(\"return\", {\n                  user: false\n                });\n\n              case 38:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 30]]);\n      }));\n\n      function authenticateUser(_x4, _x5, _x6) {\n        return _authenticateUser.apply(this, arguments);\n      }\n\n      return authenticateUser;\n    }()\n    /**\n     * Check if a given path is a protected one.\n     *\n     * @param {string} pathname\n     *   The current pathname.\n     *\n     * @return {boolean}\n     *   True if it is a protected route.\n     */\n\n  }, {\n    key: \"isNoProtectedRoute\",\n    value: function isNoProtectedRoute(pathname) {\n      return this.protectedRoutes.every(function (route) {\n        return !pathname.startsWith(route);\n      });\n    }\n  }]);\n\n  return AuthGuard;\n}();","map":{"version":3,"sources":["/home/ab/Documents/laravel-nextjs-starter-main/client/services/Auth/AuthGuard.tsx"],"names":["axios","protectedRoutes","AuthGuard","req","res","destination","get","headers","Cookie","cookie","user","status","writeHead","Location","end","props","pathname","isNoProtectedRoute","response","currentUser","data","every","route","startsWith"],"mappings":"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","sourcesContent":["/*\n|--------------------------------------------------------------------------\n| Authenticator.\n|--------------------------------------------------------------------------\n|\n| A set of functions related to user authentication. \n|\n*/\nimport axios from \"axios\";\nimport { IncomingMessage, ServerResponse } from \"http\";\nimport { protectedRoutes } from \"./../../config/config\";\n\nexport class AuthGuard {\n    /**\n     * An array of routes that should not be accessible by unauthenticated users.\n     */\n    private protectedRoutes: string[];\n\n    /**\n     * The constructor function.\n     */\n    constructor() {\n        this.protectedRoutes = protectedRoutes;\n    }\n\n    /**\n     * Get the current user from the database and redirect to dashboard if successful.\n     *\n     * @param {IncomingMessage} req\n     *   The request object.\n     * @param {ServerResponse} res\n     *   The response object.\n     * @param {string} destination\n     *   The destination URL the user will be redirected to if he's authenticated.\n     *\n     * @return {object}\n     *  An empty object. It is still necessary to return obj as getServerSideProps() requires it.\n     */\n    public async redirectOnAuthentication(\n        req: IncomingMessage,\n        res: ServerResponse,\n        destination: string\n    ) {\n        try {\n            // CSRF.\n            await axios.get(\"/sanctum/csrf-cookie\");\n\n            /**\n             * As the API call is executed on the server it by\n             * default does not have the cookies set in the browser.\n             * Fortunately, we can extract these cookies from the req object\n             * and attach them to the api call.\n             */\n            const user = await axios.get(\"/api/user\", {\n                headers: { Cookie: req.headers.cookie },\n            });\n\n            // Redirect to dashboard if user is logged in.\n            if (user.status === 200) {\n                res.writeHead(301, {\n                    Location: destination,\n                });\n                res.end();\n                return { props: {} };\n            } else {\n                return {\n                    props: {},\n                };\n            }\n        } catch (error) {\n            return { props: {} };\n        }\n    }\n\n    /**\n     * Load the currently logged in user from DB.\n     *\n     * @param {object} req\n     *   The request object.\n     */\n    public async authenticateUser(\n        req: IncomingMessage,\n        res: ServerResponse,\n        pathname: string\n    ) {\n        const isNoProtectedRoute = this.isNoProtectedRoute(pathname);\n        try {\n            // CSRF.\n            await axios.get(\"/sanctum/csrf-cookie\");\n\n            // If there are no cookies and the route is protected, redirect to login.\n            if (!req.headers.cookie && !isNoProtectedRoute) {\n                /**\n                 * No further redirect if we're already on the login\n                 * path, as we otherwisely would be caught in an\n                 * infinite loop of redirections to /user/login.\n                 */\n                if (pathname === \"/user/login\") {\n                    res.end();\n                    return { user: false };\n                }\n\n                res.writeHead(302, {\n                    Location: \"/user/login\",\n                });\n                res.end();\n                return { user: false };\n            }\n\n            /**\n             * As the API call is executed on the server it by\n             * default does not have the cookies set in the browser.\n             * Fortunately, we can extract these cookies from the req object\n             * and attach them to the api call.\n             */\n            const response = await axios.get(\"/api/user\", {\n                headers: { Cookie: req.headers.cookie },\n            });\n\n            // Abort if request was not successful.\n            if (response.status !== 200) {\n                res.end();\n                return { user: false };\n            }\n\n            // New var with the current user data.\n            const currentUser = response.data;\n\n            // If user is authenticated and he requests login or register, redirect to dashboard.\n            if (\n                currentUser &&\n                (pathname === \"/user/register\" || pathname === \"/user/login\")\n            ) {\n                res.writeHead(302, {\n                    Location: \"/dashboard\",\n                });\n                res.end();\n            }\n            // Redirect to login if user is not authenticated and tries to access protected route.\n            else if (!currentUser && !isNoProtectedRoute) {\n                res.writeHead(302, {\n                    Location: \"/user/login\",\n                });\n                res.end();\n                return { user: false };\n            }\n\n            // Return the currently authenticated user.\n            return {\n                user: currentUser,\n            };\n        } catch (error) {\n            /**\n             * If the authentication fails (e.g. invalid session)\n             * the API will send a 401 response. If we're on a\n             * protected route, redirect to the login page.\n             */\n\n            if (\n                error.response &&\n                error.response.status === 401 &&\n                !isNoProtectedRoute\n            ) {\n                if (pathname === \"/user/login\") {\n                    return { user: false };\n                }\n                res.writeHead(302, {\n                    Location: \"/user/login\",\n                });\n                res.end();\n            }\n            return { user: false };\n        }\n    }\n\n    /**\n     * Check if a given path is a protected one.\n     *\n     * @param {string} pathname\n     *   The current pathname.\n     *\n     * @return {boolean}\n     *   True if it is a protected route.\n     */\n    public isNoProtectedRoute(pathname: string): boolean {\n        return this.protectedRoutes.every((route) => {\n            return !pathname.startsWith(route);\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}